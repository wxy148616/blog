<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决:Failed to add /run/systemd/ask-password to directory watch:No space left on device]]></title>
    <url>%2F2019%2F05%2F14%2F%E8%A7%A3%E5%86%B3No-space-left-on-device%2F</url>
    <content type="text"><![CDATA[今天运行了一下privoxy，蹦出来了：Failed to add /run/systemd/ask-password to directory watch: No space left on device df查了一下磁盘空间，完全够用，找了一下解决方法，做个记录 1234sudo -iecho 1048576 &gt; /proc/sys/fs/inotify/max_user_watchesexitsudo vim /etc/sysctl.conf 在sysctl.conf中加入： 1fs.inotify.max_user_watches=1048576 参考：https://askubuntu.com/questions/828779/failed-to-add-run-systemd-ask-password-to-directory-watch-no-space-left-on-dev]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python list元素移动]]></title>
    <url>%2F2019%2F05%2F13%2Fpython-list%E5%85%83%E7%B4%A0%E7%A7%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[有更好的建议可以发邮件讨论，感谢 思路 1、得到要移动元素的当前下标2、pop出要移动的元素3、计算移动位置，insert进列表 实现 12345678# 把a2向右移动两位list_a = ['a1', 'a2', 'a3', 'a4']index_a2 = list_a.index('a2')a2 = list_a.pop(index_a2)# 向右移动时注意index小于零的情况insert_a2 = index_a2 + 2list_a.insert(insert_a2, a2)print(list_a) # ['a1', 'a3', 'a4', 'a2']]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python四舍五入保留两位小数]]></title>
    <url>%2F2019%2F05%2F12%2Fpython%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%2F</url>
    <content type="text"><![CDATA[四舍五入这个问题竟然出乎意料的不简单 出现问题 失败一：使用&quot;%.2f&quot; 12a = 1.335print("%.2f" % a) # 输出1.33 失败二：使用round() 12a = 1.335print(round(a, 2)) # 输出1.33 失败三：使用Decimal() 123from decimal import Decimala = 1.335print(Decimal(a).quantize(Decimal('0.00'))) #输出1.33 解决问题： a+0.001 12a = 1.335print(round(a + 0.001, 2)) # 输出 1.34 这种方法也有点问题，保留两位小数要加0.001，三位的时候就要加0.0001，不够灵活，暂时没有发现更好的方法，先记一下]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端配置ssh秘钥登录]]></title>
    <url>%2F2019%2F05%2F11%2F%E7%BB%88%E7%AB%AFssh%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[首先生成秘钥 远程服务端 生成秘钥 1ssh-keygen 中间会让输入命名、密码、地址，可以直接回车键过去 重命名公钥，配置权限 1234cd ~/.sshmv id_rsa.pub authorized_keyschmod 600 authorized_keys #修改公钥为只有属主有读写权限（安全考虑）chmod 700 ~/.ssh #修改.SSH目录为只有属主有读、写、执行权限（安全考虑） 重启ssh 1/etc/init.d/ssh restart 复制秘钥 1vim id_rsa 复制id_rsa的内容粘贴到客户端 本地客户端 把服务端复制的秘钥保存到一个文件中, 文件名不要有后缀 例：保存文件为~/.ssh/server_rsa 修改保存的秘钥权限 1chmod 600 server_rsa 到这一步就已经可以使用秘钥登录了，虽然有点麻烦 1ssh -p xx root@IP -i ~/.ssh/server_rsa 修改ssh的config配置文件，简化ssh登录 1vim ~/.ssh/config 把下面的代码复制到config中12345Host abc # abc是自己命名的 HostName 服务器IPUser 用户名Port 端口 # -pIdentityFile 保存的秘钥地址 # -i 保存config文件，直接ssh abc就可以免密登录了 参考：https://segmentfault.com/a/1190000015362485]]></content>
      <tags>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django-日志]]></title>
    <url>%2F2019%2F05%2F10%2Fdjango-%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[Django的日志使用了python的logging模块，需要在settings中进行配置 logging模块logging模块由四部分组成 记录器 记录器配置具有日志级别。此日志级别描述了记录器将处理的消息的严重性。Python定义了以下日志级别：DEBUG： 用于调试目的的低级系统信息INFO： 一般系统信息WARNING： 描述已发生的小问题的信息。ERROR： 描述已发生的主要问题的信息。CRITICAL： 描述已发生的严重问题的信息 处理器 处理器是确定记录器中每条消息发生情况的引擎。它描述了特定的日志记录行为，例如将消息写入屏幕，文件或网络套接字。 与记录器一样，处理器也具有日志级别。如果日志记录的日志级别未达到或超过处理程序的级别，则处理程序将忽略该消息。 记录器可以有多个处理器，每个处理器可以具有不同的日志级别。以这种方式，可以根据消息的重要性提供不同形式的通知。 过滤器 过滤器用于提供对日志记录从记录器传递到处理程序的附加控制。 默认情况下，将处理满足日志级别要求的任何日志消息。但是，通过安装筛选器，可以在日志记录过程中添加其他条件。例如，您可以安装仅允许ERROR发出来自特定源的消息的过滤器。 过滤器还可用于在发出之前修改日志记录。例如，如果满足一组特定条件，您可以编写一个过滤器，将ERROR日志记录降级 为WARNING记录。 过滤器可以安装在记录器或处理器上; 可以在链中使用多个过滤器来执行多个过滤操作。 格式化程序 最终，日志记录需要呈现为文本。格式化程序描述该文本的确切格式。格式化程序通常由包含LogRecord属性的Python格式化字符串组成 ; 但是，也可以编写自定义格式化程序来实现特定的格式化行为。 示例 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455LOG_PATH = 'xx/xx/'LOGGING = &#123; 'version': 1, #定义了配置文件的版本 'disable_existing_loggers': False, ## True表示禁用logger # 格式化 'formatters': &#123; 'default': &#123; 'format': '%(levelname)s %(asctime)s %(module)s %(funcName)s %(msecs)s %(message)s' &#125;, 'simple': &#123; 'format': '%(levelname)s %(message)s' &#125;, &#125;, # 处理日志的方式 'handlers': &#123; 'v_handlers': &#123; # 级别 'level': 'DEBUG', # 存储方式 "class": 'logging.handlers.RotatingFileHandler', # 日志文件大小 'maxBytes': 5 * 1024, 'encoding': 'utf8', # 日志文件路径 'filename': '&#123;&#125;salary_all.log'.format(LOG_PATH), # 格式化方式 'formatter': 'default', &#125;, 'error': &#123; 'level': "ERROR", 'class': 'logging.handlers.RotatingFileHandler', 'maxBytes': 5 * 1024, 'encoding': 'utf8', 'filename': '&#123;&#125;salary_error.log'.format(LOG_PATH), 'formatter': 'simple' &#125; &#125;, # 配置日志的处理方式 'loggers': &#123; 'django': &#123; 'handlers': ['v_handlers'], 'propagate': True, &#125;, 'django.request': &#123; 'handlers': ['error'], 'level': 'ERROR', 'propagate': True &#125; &#125;, # 过滤器 'filters': &#123; &#125; &#125; format format %(levelno)s 日志的级别数字形式 %(levelname)s 日志级别的名称 %(pathname)s 当前执行程序的路径 %(filename)s 当前执行程序名 %(funcName)s 当前的函数 %(lineno)d 记录日志的当前行号 %(asctime)s 日期时间 %(msecs)s 毫秒级的时间 %(thread)d 线程ID %(threadName)s 线程名称 %(process)d 进程ID %(message)s 记录的日志信息]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django项目部署]]></title>
    <url>%2F2019%2F05%2F09%2Fdjango-%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[django == 1.11.16nginx == 1.10.3 项目编写 略 安装nginx 略(前一篇有详细介绍) 配置uwsgi 创建 xxx.ini 文件 1234567[uwsgi]socket=:9000 # 端口chdir=/mnt/project/project_api # 项目路径 包含manage.py的路径module=pro.wsgi #pro为包含wsgi.py文件的文件名master=trueprocesses=4vacuum=true 配置nginx 打开/etc/nginx/nginx.conf文件http{}中添加一个server 12345678910111213141516server &#123; listen 80; server_name 域名 或者 localhost; charset UTF-8; access_log /var/log/nginx/djangohost.access.log; error_log /var/log/nginx/djangohost.error.log; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:9000; uwsgi_read_timeout 2; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 重启nginx 12345ps -ef | grep nginxkill -HUP &lt; pid &gt;# 或者使用 serviceservice nginx restart 启动项目 1uwsgi --ini xxx.ini]]></content>
      <tags>
        <tag>项目部署</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git钩子自动更新服务器代码]]></title>
    <url>%2F2019%2F05%2F08%2Fgit%E9%92%A9%E5%AD%90%2F</url>
    <content type="text"><![CDATA[手动提交好累的，自动部署才是王道 服务器端 创建一个裸仓库 1234pwd # /home/www/git init --bare project_xxx.gitcd project_xxx.git/hooks/cp post-update.sample post-update 创建一个普通的仓库 ，这一步就是为了明确表示一下仓库其实是有两个的，这个仓库才是代码的存储位置 12pwd # /home/www/mkdir blog 更改post-update中的内容为: 12345678910#!/bin/shunset GIT_DIR DIR_ONE=/home/www/blog／ # 更新后的代码会存储在这个文件夹中，文件夹需要存在 cd $DIR_ONEgit initgit remote add gitee https://gitee.com/project.git # 码云/GitHub代码仓库地址，如果不需要推到远程仓库，可以把这一步和最后的push去掉git remote add origin /home/www/project_xxx.git # 路径指向裸仓库git reset --hard # git clean -dfgit pull origin mastergit push gitee master # 把代码推到远程仓库 配置git，因为用的是服务器，没有配置公钥，直接偷懒配置一下git的全局配置，不需要推到远程仓库可以省略这一步 123git config --global user.name "name"git config --global user.email "email"git config --global credential.helper store 然后使用git推一次代码，记录一下远程仓库的密码，脚本在推代码的时候就不需要再验证了 客户端 进入项目目录 12git initgit remote add origin 服务器地址:/home/project_xxx.git # 服务端创建的裸仓库的地址 然后就可以在客户端进行操作了 参考:git book: 服务器上的-Git-在服务器上搭建-Git用 Git 钩子进行简单自动部署]]></content>
      <tags>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ab压力测试(入门)]]></title>
    <url>%2F2019%2F05%2F07%2Fab%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[记录一下最近了解的压力测试工具 ab 全称: apache bench 测试命令:1ab -c 1000 -n 100 -p data.txt -T application/json -H "token:xxx" -w "http://127.0.0.1/test/" &gt;&gt; test.html -c: 请求数量-n: 请求并发量-p: 请求参数文件-T: Content-type-H: 追加一个请求头-w: 测试结果以html形式存储在test.html文件中, 不添加 -w 和 &gt;&gt; test.html 结果会打印在终端 -p 的参数文件内的参数格式是由Content-type决定的 参考: http://httpd.apache.org/docs/2.4/programs/ab.html]]></content>
      <tags>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python处理excel合并单元格]]></title>
    <url>%2F2019%2F05%2F06%2Fpython%E5%A4%84%E7%90%86%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[可以使用xlrd，也可以使用openpyxl，但是openpyxl读取不了.xls格式的Excel，需要转成xlsx，有点麻烦，所以使用了xlrd。 读取 打开文件 xlrd也遇到了一点问题，文件如果是xls文件直接打开，在提取合并单元格的时候会拿不到数据，需要加上 formatting_info=True，formatting_info=True的时候打开.xlsx文件会报错NotImplementedError: formatting_info=True not yet implemented，加个if就好了12345workbook = xlrd.open_workbook(path)if path.split('.xl')[1] == 's': workbook = xlrd.open_workbook(path, formatting_info=True)# 获取sheetsheet = workbook.sheet_by_index(0) 获取所有的合并单元格坐标 123456# 获取列数r_num = sheet.nrows# 获取行数c_num = sheet.ncolsmerge = sheet.merged_cellsprint(merge) # [(1, 5, 0, 1), (1, 5, 1, 2)], 对应上面两个合并的单元格 组装数据 1234567891011121314read_data =[]for r in range(r_num): li = [] for c in range(c_num): # 读取每个单元格里的数据，合并单元格只有单元格内的第一行第一列有数据，其余空间都为空 cell_value = sheet.row_values(r)[c] # 判断空数据是否在合并单元格的坐标中，如果在就把数据填充进去 if cell_value is None or cell_value == '': for (rlow, rhigh, clow, chigh) in merge: if rlow &lt;= r &lt; rhigh: if clow &lt;= c &lt; chigh: cell_value = sheet.cell_value(rlow, clow) li.append(cell_value) read_data.append(li) 写入使用的是xlwt 直接上代码 12345678910111213141516171819202122232425f = xlwt.Workbook()sheet1 = f.add_sheet('sheet1', cell_overwrite_ok=True)headers = ['序号', "姓名", '列表', '1月', '2月', '3月', '4月', '5月']name = ['1-AAA', '2-BBB', '3-CCC', '4-DDD']status = ['累计应发数', '累计专项扣除-五险一金', '累计免税收入', '累计扣个税']# 生成第一行headerfor i in range(0,len(headers)): sheet1.write(0,i,headers[i])# 生成序号、姓名单元格i, j = 1, 0while i &lt; 10*len(name) and j &lt; len(name): sheet1.write_merge(i,i+9,0,0,name[j].split('-')[0]) sheet1.write_merge(i,i+9,1,1,name[j].split('-')[1]) i += 10 j += 1#生成列表i = 0while i &lt; 10*len(column0): for j in range(0,len(status)): sheet1.write(j+i+1,3,status[j]) i += 10# 保存f.save(path) Django导出 服务端代码 1234567891011excel_stream = io.BytesIO()# BytesIO流（在内存中读写）f.save(excel_stream)res = excel_stream.getvalue()excel_stream.close()response = HttpResponse(content_type='application/vnd.ms-excel')from urllib import parsefile_name = str(path.name).split('.xls')[0] + '(计算后).xls'response['Content-Disposition'] = 'attachment;filename=' + parse.quote(file_name)response.write(res)return response 前端 写一个简单的form表单就行了]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux服务器Nginx部署图片]]></title>
    <url>%2F2019%2F05%2F05%2FLinux%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[部署一个静态页面做测试 文件路径是这样的 1234567.└── background ├── images │ ├── 1.jpg │ ├── 2.jpg │ └── 3.jpg └── index.html index.html 中的路径是这样的 1style="background-image:url('/images/1.jpg')" /etc/nginx/nginx.conf 是这样的 12345678910111213server &#123; listen 80; server_name background.wxy.email; # 域名/ip charset utf-8; location / &#123; root /home/www/background; # html存储路径 index index.html; # html名称 &#125; location /images/ &#123; alias /home/www/background/images/; # 图片存储路径 autoindex on; &#125; &#125; 修改文件夹权限 1sudo chmod 777 -R /home/www/background/ 启动 / 重启nginx 12sudo service nginx start # 启动sudo service nginx reload #重启 浏览器中输入网址 参考项目：http://background.wxy.email/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python之bisect模块, 有序列表插入数据]]></title>
    <url>%2F2019%2F04%2F27%2Fpython-bisect%2F</url>
    <content type="text"><![CDATA[bisect是python的内置模块, 可以使用它来插入数据, 并且插入的数据不会影响列表的排序, 但是原有列表需要是有序的, 并且不能是倒序. bisect.bisect(data, n), 查找并返回n插入的位置下标, 但并不会插入. 123data = [1, 7, 3, 8, 5]data.sort() bisect.bisect(data, 6) # 返回 3 bisect.insort(data, n), 插入n, 不会影响列表顺序. 12bisect.insort(data, 6)print(data) # [1, 3, 5, 6, 7, 8] bisect.bisect_left()、bisect_right(), 这两个函数用来处理插入重复数值的情况，返回将会插入的位置. 123data = [1, 3, 5, 6, 7, 8]bisect.bisect_left(data, 6) #返回 3bisect.bisect_reght(data, 6) #返回 4 bisect.insort_left()、insort_right(), 对应bisect.bisect_left()、bisect_right(), 用来插入数据. 12345bisect.insort_left(data, 6)print(data) #返回 [1, 3, 5, 6, 6, 7, 8] 元素`5`后的`6`是新插入的数据bisect.insort_reght(data, 6)print(data) #返回 [1, 3, 5, 6, 6, 6, 7, 8] 元素`7`前的`6`是新插入的数据#insort_left从左侧插入, insort_reght从右侧插入]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python socket 实现服务端和客户端数据传输（TCP）]]></title>
    <url>%2F2019%2F03%2F24%2FPython-socket%2F</url>
    <content type="text"><![CDATA[TCP数据传输 服务器端 1234567891011121314151617181920212223242526272829import socket#创建一个socket对象socket_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)host = "127.0.0.1"port = 9999#绑定地址socket_server.bind((host, port))#设置监听socket_server.listen(5)# socket_server.accept()返回一个元组, 元素1为客户端的socket对象, 元素2为客户端的地址(ip地址，端口号)client_socket, address = socket_server.accept()#while循环是为了让对话持续while True: #接收客户端的请求 recvmsg = client_socket.recv(1024) #把接收到的数据进行解码 strData = recvmsg.decode("utf-8") #设置退出条件 if strData == 'q': break print("接收: %s" % strData) #输入 msg = input("发送: ") #发送数据，需要进行编码 client_socket.send(msg.encode("utf-8"))#关闭服务器端socket_server.close() 客户端 1234567891011121314151617181920212223import socket#创建一个socket对象client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)host = "127.0.0.1"port = 9999#连接服务端client.connect((host, port))while True: send_msg = input("发送: ") #设置退出条件 if send_msg == "q": break send_msg = send_msg #发送数据，编码 client.send(send_msg.encode("utf-8")) #接收服务端返回的数据 msg = client.recv(1024) #解码 print("接收：%s", % msg.decode("utf-8"))#关闭客户端client.close() 流程图 图片来源：https://blog.csdn.net/slavik_/article/details/82430717]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx的安装和配置]]></title>
    <url>%2F2019%2F01%2F26%2Fnginx%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[仅供参考, 不同系统操作可能会不一样, 中间遇到错误, 找一下错误原因, 一般是单词”error“后的一句, 复制, 百度, vim操作下面有注释 安装nginx 方法一：这个是最简单的方法，但是很有可能会失败，这里搞定了就能直接去配置nginx了 说明 命令 1.安装g++a sudo apt-get install g++ 2.使用apt直接安装 sudo apt-get install nginx 3.启动 service nginx start 方法二 下载nginx及相关组件输入 : 12345cd /usr/local/src/ wget http://nginx.org/download/nginx-1.10.2.tar.gzwget http://www.openssl.org/source/openssl-fips-2.0.10.tar.gzwget http://zlib.net/zlib-1.2.11.tar.gzwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.40.tar.gz 安装c++编译环境 12yum install gcc-c++ 或者 apt-get install g++ 中间需要确认一次, 输入: y 安装nginx及相关组件安装openssl: 1234tar zxvf openssl-fips-2.0.10.tar.gzcd openssl-fips-2.0.10./config &amp;&amp; make &amp;&amp; make installcd /usr/local/src/ 或者 cd .. 回到src文件夹中 安装pcre: tar zxvf pcre-8.40.tar.gz 123cd pcre-8.40./configure &amp;&amp; make &amp;&amp; make installcd /usr/local/src/ 或者 cd .. 回到src文件夹中 安装zlib: tar zxvf zlib-1.2.11.tar.gz 123cd zlib-1.2.11./configure &amp;&amp; make &amp;&amp; make installcd /usr/local/src/ 或者 cd .. 回到src文件夹中 安装nginx : tar zxvf nginx-1.10.2.tar.gz 12cd nginx-1.10.2./configure &amp;&amp; make &amp;&amp; make install 启动 nginx 先找到nginx的安装位置, 输入: 1whereis nginx # 得到路径 例如: /usr/local/nginx 进入得到的路径: 1cd /usr/local/nginx 启动: 123/usr/local/nginx/sbin/nginx或者 cd /usr/local/nginx/sbin/ 输入: nginx 或 ./nginx 查看启动状态: 1ps -aux | grep nginx # 出现三条记录就表示已经启动成功 如果启动成功, 不改配置文件打开自己的域名也能看到一个默认页面, 说明域名已经绑定成功​​ 配置nginx 进入nginx配置文件夹 12whereis nginx # 得到路径 例如: /usr/local/nginxcd /usr/local/nginx 打开配置文件 1vim nginx.conf ​​找到如图所示的地方, 位置和文件名称改为自己需要展示的网页 注释 nginx操作命令: 启动 1/usr/local/nginx/sbin/nginx 停止/重启 1/usr/local/nginx/sbin/nginx -s stop(quit、reload) 命令帮助 1/usr/local/nginx/sbin/nginx -h 验证配置文件 1/usr/local/nginx/sbin/nginx -t 配置文件 1vim /usr/local/nginx/conf/nginx.conf vim简单操作命令: 深入了解百度 开启编辑：按“i”或者“Insert”键 退出编辑：“Esc”键 退出vim：“:q” 保存vim：“:w” 保存退出vim：“:wq” 不保存退出vim：“:q!” 查看当前系统版本, 输入: 1cat /etc/redhat-release 或 : lsb_release -a 参考: https://www.cnblogs.com/taiyonghai/p/6728707.html]]></content>
      <tags>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python os文件操作]]></title>
    <url>%2F2018%2F12%2F25%2FPython-os%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[直接上代码 12345678910111213141516171819202122232425262728293031323334import osimport shutilfilePath = '/xxx/'newPath = '/yyy/'# 创建文件夹os.mkdir(path)# os.listdir(filePath) 获取文件夹目录for filename in os.listdir(filePath): # 获取文件创建时间，两种方式结果相同 t = os.stat(filePath+"/"+filename).st_ctime t2 = os.path.getctime(filePath+"/"+filename) # 获取文件访问时间 t3 = os.path.getatime(filePath+"/"+filename) t4 = os.stat(filePath+"/"+filename).st_atime # 获取文件修改时间 t5 = os.path.getmtime(filePath+"/"+filename) t6 = os.stat(filePath+"/"+filename).st_mtime # 获取文件大小，单位byte t7 = os.path.getsize(filePath+"/"+filename) t8 = os.stat(filePath+"/"+filename).st_size # 复制文件 shutil.copyfile(filePath, newPath) # 复制文件夹，newPath必须不存在 shutil.copytree(filePath,newPath) # 移动文件/文件夹 shutil.move(filePath, newPath) # 重命名文件/文件夹 os.rename(filePath,newPath) # 删除文件，不能删除文件夹 os.remove(filePath+"/"+filename)# 删除文件夹，只能删除空的文件夹os.rmdir(filePath)# 删除文件夹，空的、非空的文件夹都能删除shutil.rmtree(filePath)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git本地项目上传到远程仓库]]></title>
    <url>%2F2018%2F09%2F09%2Fgit-init%2F</url>
    <content type="text"><![CDATA[Git的使用 进入项目首目录 1234git init #初始化仓库git add . git commit -m "提交" # 提交代码git remote add xxx git@仓库地址 复制自己的公钥，添加到远程仓库 push代码 123git push xxx master或者是git push -f xxx master]]></content>
      <tags>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python栈的简单实现]]></title>
    <url>%2F2018%2F08%2F10%2Fpython%E6%A0%88%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[栈(stacks)是一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表, 它按照先进后出的原则存储数据(Last In First Out - LIFO)。 代码(使用list): 123456789101112131415161718192021222324252627282930313233343536373839class Stack(object): # 初始化 def __init__(self): self.items = [] # 判断是否为空 def is_empty(self): return self.items == [] # 返回栈顶元素 def peek(self): if self.is_empty(): raise KeyError("stack is None") return self.items[len(self.items) - 1] #返回栈的大小 def size(self): return len(self.items) # 入栈，把新的元素放进栈里 def push(self, item): self.items.append(item) # 出栈，把栈顶元素丢出去 def pop(self): if self.is_empty(): raise KeyError("stack is None") return self.items.pop()if __name__ == '__main__' : a_stack = Stack() # 插入元素 a_stack.push('一') a_stack.push('二') a_stack.push('三') print(a_stack.size()) # 3 print(a_stack.peek()) # 三 print(a_stack.pop()) # 三 print(a_stack.peek()) # 二 print(a_stack.size()) # 2 print(a_stack.is_empty()) # False a_stack.__init__() print(a_stack.is_empty()) # True]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的内存管理机制]]></title>
    <url>%2F2018%2F07%2F23%2Fpython%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Python 默认内存处理机制为GC(垃圾回收) 内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。 内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后, 由于设计错误, 失去了对该段内存的控制, 因而造成了内存的浪费, 导致程序运行速度减慢甚至系统崩溃等严重后果。有 __del__() 函数的对象间的循环引用是导致内存泄漏的主凶。 不使用一个对象时使用: del object 来删除一个对象的引用计数就可以有效防止内存泄漏问题。通过 Python 扩展模块 gc 来查看不能回收的对象的详细信息, 也可以通过 sys.getrefcount(obj) 来获取对象的引用计数, 并根据返回值是否为 0 来判断是否内存泄漏。内存管理机制一. 引用计数通过引用计数来保持对内存中的变量跟踪Python内部记录中所有在使用对象各有多少个引用。Python中有个内部跟踪变量叫做引用计数器, 每个变量有多少个引用, 简称引用计数。当对象被创建时就创建了一个引用计数。当某个对象的引用计数为0时, 对象就不在需要, 就列入了垃圾回收队列。二. 垃圾回收 引用计数：每个对象中都有ob-refcnt来做引用计数。当一个对象被引用, ob-refcnt就会增加, 当引用的对象删除, 那么ob-refcnt就会减少, 当ob-refcnt为零, 就会释放该对象的内存空间。 标记清除：解决循环引用的问题。先按需分配, 等到没有空闲内存的时候, 从寄存器和程序栈上的引用出发, 遍历所有对象和引用把所有能访问的打标记, 最后将没有标记的对象释放掉。 分代技术：提高效率, 提高垃圾回收的效率, 按照存活时间, 分成不同的集合。将内存块按照其存活时间划分为不同的集合。每个集合就称为一个“代”, 垃圾回收的频率随代的存活时间增大而减小。Python默认定义分代对象集合, 引用数越大, 对象的存活时间越长。 三. 内存池机制 在Python中, 大多数申请的都是小块的内存, 会执行大量的malloc和free操作。Python引入了一个内存池机制, 用于管理对小块内存的申请和释放, 即Pymalloc机制。它将不用的内存放到内存池而不是返回给操作系统。 当申请的内存小于256字节时, PyObject_Malloc会在内存池中申请内存; 当申请的内存大于256字节时, PyObject_Malloc的行为将蜕化为malloc的行为。当然, 通过修改Python源代码, 我们可以改变这个默认值, 从而改变Python的默认内存管理行为。 对于Python对象, 如整数, 浮点数和List, 都有其独立的私有内存池, 对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数, 用于缓存这些整数的内存就不能再分配给浮点数。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python简单操作txt文件]]></title>
    <url>%2F2018%2F07%2F20%2Fpython%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[还是以最简单的例子开始，先来操作txt文件吧 打开文件 使用open()打开文件 1f = open("xxx.txt", "w+") 打开模式 r: 只能读, 若文件不存在报错r+: 可读可写, 若文件不存在报错, 如果写入会覆盖源文件w: 只能写, 若文件不存在创建, 写入会覆盖源文件w+: 可读可写, 若文件不存在创建, 写入会覆盖源文件a: 只能写, 若文件不存在创建, 追加写入a+: 可读可写, 若文件不存在创建, 追加写入 编辑文件12345f.read() # 读取整个文件f.read(n) # 每次读取n个字节, 指针向后移动f.readline() # 每次读取一行, 指针向后移动f.readlines() # 读取整个文件, 把文件以行分割, 放入一个列表中f.write("写入数据\n") # \n表示换行 注意: 文件的大小不能确定的时候最好不要使用read()和readlines()直接读取, 当文件过大时会时程序崩溃, 可以使用read(n)指定每次读取的字节数. 关闭文件1f.close()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署]]></title>
    <url>%2F2018%2F06%2F29%2Fhexo%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[本地搭建完成只是一个开始，想要真正的用起来当然少不了部署了。 部署到服务器 安装hexo-deployer-git 1npm install hexo-deployer-git --save 修改_config.yml配置 12345deploy: type: git repo: 仓库地址 repository branch: 分支 message: 提交信息 生成站点文件并推送至远程库。 1hexo clean &amp;&amp; hexo deploy 前者清除站点文件，后者重新生成站点文件并将之推送到指定的库分支。 配置nginx 打开nginx配置文件，新增一个server 123456789server &#123; listen 80; server_name www.wxy.email; 域名 charset utf-8; location / &#123; root /home/blog; 服务器上的代码目录路径 index index.html; &#125;&#125; 重启nginx shell1service nginx reload 这样就OK了，简单到意外…]]></content>
      <tags>
        <tag>项目部署</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[先写第一篇：hexo快速入门]]></title>
    <url>%2F2018%2F06%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[之前朋友介绍了hexo，但是当时没有想着写博客就没有看，这几天又忽然想起来了，用了一下试试，真的挺不错的，简单实用。 首先需要配置环境 安装git和Node.js 123sudo apt-get install git-corewget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | shnvm install stable 安装hexo 1npm install -g hexo-cli 开始使用 新建文件夹 123hexo init 文件名cd 文件名npm install 配置类的文件大部分在_config.yml中 写一篇新文章，并启动12hexo new "写一篇新文章"hexo server # 启动 访问http://localhost:4000/就可以了 这只是一个快速入门，具体功能请看官网]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
